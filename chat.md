# 251210 14:56
## Q
- 上の説明のなかで、C#はdefault runspace側にいるという理解でよいでしょうか？
- C#が注入している変数はすべてのグローバル変数ですか？
- TTState の Defaultプロパティ、Applyプロパティ、Watchプロパ低lはすべて、独立したrunspaceで実行されていますか？
- Watchプロパティはデフォルトrunspaceで動作しているC#のTTApplicationやTTPanelに対するイベントを設定していますが、問題なく設定されますでしょうか？

## A
ご質問への回答です。非常に鋭い指摘ですが、結論から言えば「問題なく動作します」。 構造を以下に整理します。

1. C#の位置付け
C#はdefault runspace側にいるという理解でよいでしょうか？

少し違います。 C#（コンパイルされたバイナリ）は「家そのもの（プロセス全体）」です。 Runspace（Default / 独立）は、その家の中にある「部屋」です。 C#で生成されたオブジェクト（TTApplication のインスタンスなど）は、ヒープメモリ という共有領域に存在します。 thinktank.ps1（Default Runspace）も、アプリ内スクリプト（独立 Runspace）も、この共有メモリ上の 「同じC#オブジェクト」 を参照しています。

2. 注入変数の範囲
C#が注入している変数はすべてのグローバル変数ですか？

はい。 View_TTApplication.cs で以下のように注入しています。 これらは独立Runspace側の $global スコープに設定されます。

$global:Application
$global:Models
$global:RootPath
$global:ScriptPath

3. TTStateの実行場所
TTState の Default, Apply, Watch はすべて、独立したrunspaceで実行されていますか？

はい、その通りです。 New-TTState コマンド自体が独立Runspace内で定義・実行されており、そこで登録される ScriptBlock（{ ... } の中身）も、独立Runspaceのメモリ空間に保存されます。したがって、実行時も独立Runspaceのコンテキスト（変数スコープなど）で動作します。

4. Watch（イベント設定）の動作
Watchプロパティはデフォルトrunspaceで動作しているC#のTTApplicationやTTPanelに対するイベントを設定していますが、問題なく設定されますでしょうか？

問題なく動作します。 ここがポイントですが、イベントを設定する対象（TTPanelなど）は C#オブジェクトであり、Runspaceに依存しない共有の存在 です。

独立Runspace内のスクリプトが、共有されている TTPanel オブジェクトのイベント（.Add_...）に、自身の ScriptBlock を登録します。
C#側（UIスレッド）でイベントが発生します。
登録されていた ScriptBlock が呼び出されます。
修正前: 呼び出し時にスレッドが異なっていたため問題が起きていました。
修正後: C#側もScriptBlock側も 「同じUIスレッド」 上で動作するため、シームレスに実行されます。また、ScriptBlock内の変数は「独立Runspace」のものが見える状態で実行されます。
つまり、「オブジェクトは共有、実行ロジックと変数は独立Runspace持ち、スレッドは共通」という構成になっています。





# 251210 14:44
## Q
thinktank.ps1と、TTEventとして呼び出されるスクリプトは同じスレッド、同じスコープで実行されるでしょうか？

## A
ご質問ありがとうございます。とても重要な点です。

結論から申し上げますと、

スレッド: 「ほぼ同じ」 と考えて差し支えありません（全てメインスレッド/UIスレッド上で動作します）。
スコープ（変数や関数などの見える範囲）: 「完全に別物」 です。
詳細は以下の通りです。

1. スレッドについて（同じ）
thinktank.ps1 は PowerShell プロセスの メインスレッド で実行されます。
このスクリプト内で [ThinktankApp.TTApplication]::new(...) を実行しているため、アプリ本体（C#側）もこの メインスレッド 上に生成されます。
TTEvent（内部スクリプト）も、今回の修正（UseCurrentThread）により、呼び出し元である メインスレッド 上で実行されます。 つまり、これら3者は物理的には 同一のUIスレッド を共有しており、だからこそ画面操作などがスムーズに行えます。
2. スコープについて（異なる）
thinktank.ps1 は、あなたが起動した PowerShell コンソール（ホスト）の デフォルトRunpsace で動作しています。
一方、TTEvent はアプリ内部で RunspaceFactory.CreateRunspace() によって作られた 独立したRunspace で動作しています。
影響:

thinktank.ps1 で定義した変数（例: $myVar = 10）は、アプリ内部のスクリプト（TTEvent）からは 見えません。
逆に、アプリ内部で定義した変数も thinktank.ps1 からは見えません。
両者の橋渡し役となっているのが、C#側から注入している $global:Application などの特殊な変数だけです。
「同じ部屋（スレッド）で作業しているが、お互いに見ているノート（スコープ）は違う」というイメージです。





# 251210 14:38
## Q
うまくいきました。おめでとうございます。
どのような修正をしたのか簡単に説明していただけないでしょうか？また、起動スレッド、メインスレッド、メインスレッドからよばれる PS scriptblockのスレッド、はどれが同じでどれが異なりますか？

## A
修正の解説をいたします。

修正内容の要約
問題の核心は「PowerShellの実行環境（Runspace）がバックグラウンドスレッドに紐付いていたこと」でした。

フリーズの原因（デッドロック）: キー操作（メインスレッド）からスクリプトを呼び出す際、メインスレッドは「スクリプトの完了」を待ちます。しかし、スクリプト（バックグラウンドスレッド）内で 
ShowMessage
 を呼び出すと、それが「メインスレッドで画面を表示したい（Dispatcher.Invoke）」と要求します。互いに相手の処理待ち状態となり、フリーズしていました。
表示順序の問題（Z-order）: フリーズを回避するために Dispatcher.Invoke を外すと、
ShowMessage
 はバックグラウンドスレッドで動きます。この場合、メインウィンドウ（メインスレッド所有）を親（オーナー）に指定できないため、ダイアログが独立してしまい、ウィンドウの裏に隠れる現象が起きました。
最終的な解決策: PowerShell の Runspace の設定を PSThreadOptions.UseCurrentThread に変更し、さらに初期化自体もメインスレッドで行うようにしました。これにより、スクリプトが「呼び出し元と同じスレッド（メインスレッド）」で実行されるようになり、全ての並列待ちが解消され、親子関係も正しく維持されるようになりました。
スレッドの関係性
今回の修正後の動作における各スレッドの関係は以下の通りです。

起動スレッド: アプリケーションの開始時は異なる場合がありますが、修正により重要な初期化処理はメインスレッドに合流させています。
メインスレッド（UIスレッド）: ログに表示された ThreadID: 14 です。画面描画やキー入力を担当します。
PS Scriptblockのスレッド:
修正前: 異なっていました（ThreadID: 19）。これが諸悪の根源でした。
修正後: 同じです（ThreadID: 14）。メインスレッド上で直接関数として実行されるイメージになり、安全かつ高速になりました。

